using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SeWzc.X11Sharp.SourceGenerator;

[Generator(LanguageNames.CSharp)]
public class IncrementalGenerator : IIncrementalGenerator
{
    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var xids = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (node, token) =>
                {
                    if (node is TypeDeclarationSyntax { BaseList.Types: { } types })
                    {
                        // 检查是否有 IXid 接口
                        return types.Any(type => type.Type is IdentifierNameSyntax { Identifier.ValueText: "IXid" });
                    }

                    return false;
                },
                static (context, token) =>
                {
                    // 获取类型声明语法节点
                    var typeDeclaration = (TypeDeclarationSyntax)context.Node;

                    // 获取类型声明的命名空间
                    var namespaceDeclarationSyntax = typeDeclaration.Ancestors().OfType<BaseNamespaceDeclarationSyntax>().First();
                    var namespaceName = namespaceDeclarationSyntax.Name;

                    // 获取类型名称
                    var typeName = typeDeclaration.Identifier.ValueText;

                    // 返回类型名称和类型声明语法节点
                    return (typeDeclaration, namespaceName);
                });

        context.RegisterSourceOutput(xids,
            static (context, source) =>
            {
                // 获取类型名称和类型声明语法节点
                var (typeDeclaration, namespaceName) = source;

                var keyword = typeDeclaration.Keyword.ToString();
                if (typeDeclaration is RecordDeclarationSyntax recordDeclaration)
                {
                    // 处理记录类型
                    keyword += " " + recordDeclaration.ClassOrStructKeyword;
                }

                // 生成源代码
                var sourceCode = $$"""
                    // <auto-generated/>
                    using SeWzc.X11Sharp.Structs;

                    namespace {{namespaceName}};

                    partial {{keyword}} {{typeDeclaration.Identifier}}
                    {
                        #region 运算符重载

                    // 强制转换不需要文档
                    #pragma warning disable CS1591

                        public static implicit operator ULong({{typeDeclaration.Identifier}} value)
                        {
                            return value.Id;
                        }
                        
                        public static implicit operator nuint({{typeDeclaration.Identifier}} value)
                        {
                            return value.Id;
                        }
                        
                        public static implicit operator nint({{typeDeclaration.Identifier}} value)
                        {
                            return (nint)value.Id;
                        }
                        
                        public static implicit operator int({{typeDeclaration.Identifier}} value)
                        {
                            return value.ToInt32();
                        }
                        
                        public static implicit operator uint({{typeDeclaration.Identifier}} value)
                        {
                            return value.ToUInt32();
                        }

                    #pragma warning restore CS1591

                        #endregion
                    }
                    """;

                context.AddSource($"{typeDeclaration.Identifier.ValueText}.g.cs", sourceCode);
            });
    }
}
